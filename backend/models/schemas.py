# backend/models/schemas.py
# Phase 4 — Pydantic request / response schemas

from typing import Optional
from pydantic import BaseModel, Field


# ─── Request ───────────────────────────────────────────────────────────────────

class RecommendRequest(BaseModel):
    """User preferences POSTed to /api/recommend"""
    place: str = Field(
        ...,
        min_length=1,
        description="City or neighbourhood to search in (e.g. 'Koramangala')",
        examples=["Koramangala"],
    )
    cuisine: Optional[str] = Field(
        None,
        description="Preferred cuisine type (e.g. 'Italian'). Omit for any cuisine.",
        examples=["Italian"],
    )
    max_price: Optional[int] = Field(
        None,
        gt=0,
        description="Maximum cost for two people in INR (e.g. 800)",
        examples=[800],
    )
    min_rating: Optional[float] = Field(
        None,
        ge=0.0,
        le=5.0,
        description="Minimum acceptable rating out of 5 (e.g. 4.0)",
        examples=[4.0],
    )


# ─── Response ──────────────────────────────────────────────────────────────────

class RestaurantItem(BaseModel):
    """A single cleaned restaurant entry from the Zomato dataset"""
    name: str
    location: str
    cuisines: str
    rate: Optional[float] = None
    approx_cost: Optional[int] = None
    votes: Optional[int] = None


class RecommendResponse(BaseModel):
    """
    Successful response from POST /api/recommend.
    Contains both the raw matched data and Gemini's expert review.
    """
    total: int = Field(..., description="Number of matched restaurants (up to 5)")
    restaurants: list[RestaurantItem] = Field(
        ..., description="Top-5 filtered & sorted restaurant objects"
    )
    gemini_review: Optional[str] = Field(
        None,
        description="Expert food-critic summary generated by Gemini"
    )


class ErrorResponse(BaseModel):
    """Returned when no matches are found after filtering"""
    error: str


class PlacesResponse(BaseModel):
    """Response from GET /api/places"""
    total: int
    places: list[str]
